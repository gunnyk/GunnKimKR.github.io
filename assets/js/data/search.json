[ { "title": "JavaScript - 데이터 불변성(Data Immutability)", "url": "/posts/javascript-data-immutability/", "categories": "Programming, JavaScript", "tags": "javascript, data immutability, data mutabiliry, immutable data, mutable data, immutable data type, mutable data type, primitive data, reference data, primitive data type, reference data type, 데이터 불변성, 데이터 가변성, 불변 데이터, 가변 데이터, 불변 데이터 타입, 가변 데이터 타입, 원시 값, 참조 데이터, 원시형 데이터, 참조형 데이터", "date": "2021-10-16 04:30:00 +0900", "snippet": "데이터 불변성데이터 불변성이란 변경할 수 없는 데이터의 성질을 말한다.자바스크립트 변수에 할당하는 데이터의 타입엔 원시 타입과 참조 타입이 있다.원시 타입 데이터는 불변 데이터이고 참조 타입 데이터는 가변 데이터이다.자바스크립트는 이 두 데이터 타입을 각각 다른 방식으로 변수에 저장하고 접근한다.원시 타입 데이터에 접근할 때는 값으로 접근하고 참조 타입 데이터에는 값이 저장된 메모리 공간에 대한 참조 값으로 접근한다.원시 타입 데이터에 값으로 접근let str01 = &#39;Gunn&#39;;let str02 = str01;str01 = &#39;Jun&#39;;console.log(str01); // Junconsole.log(str02); // Gunn메모리 공간에 저장된 원시 데이터변수 str01에 Gunn을 할당하고 변수 str02에 변수 str01의 값을 할당했다.이때 자바스크립트는 변수 str01이라는 식별자가 저장된 메모리 공간을 찾고 str01이 가리키는 메모리 리 주소 5001을 변수 str02도 가리키게 한다.4번 줄에서 변수 str01에 Jun을 재할당 할 때 새로운 메모리 공간에 Jun을 저장하고 변수 str01을 찾은 다음 새로운 메모리 주소인 5002를 가리키게 한다.즉, 변수 str01에 새로운 값을 재할당할 때 메모리 주소 5001에 저장된 Gunn이라는 값이 Jun으로 바뀌는 것이 아닌 새로운 메모리 공간에 Jun이라는 값을 저장하고 변수 str01이 그 메모리 공간을 가리키게 하는 것이다.이를 불변 데이터라고 하는 것이다.참조 타입 데이터에 참조 값으로 접근let obj01 = { name: &#39;Gunn&#39;, height: 181};let obj02 = obj01;obj01.name = &#39;Jun&#39;;console.log(obj01); // {name: &#39;Jun&#39;, height: 181}console.log(obj02); // {name: &#39;Jun&#39;, height: 181}메모리 공간에 저장된 참조 데이터변수 obj01에 객체 {name: &#39;Gunn&#39;, height: 181}를 할당하고 변수 obj02에 변수 obj01의 값을 할당했다.자바스크립트는 참조 타입 데이터를 참조 값으로 접근하는데 객체의 프로퍼티가 저장된 메모리 공간에 대한 참조 값으로 값에 접근한다. 참조 값은 객체가 저장된 메모리 공간의 주소이다.7번 줄에서 변수 obj01의 저장된 객체의 name 프로퍼티 값을 Jun으로 재할당을 했다.이때 Jun을 새로운 메모리 공간에 저장하고 변수 obj01이라는 식별자가 저장된 메모리 공간을 찾는다.obj01은 메모리 주소 3001을 가리키고 이 메모리 주소는 다시 객체의 프로퍼티가 저장된 메모리 주소 5001~500x를 가리킨다.name 프로퍼티의 메모리 주소가 가리켰던 메모리 주소 3002를 Jun이 저장된 메모리 주소 3004로 업데이트한다.프로퍼티 name이 가리키는 메모리 주소는 바꼈지만, 변수 obj01과 obj02가 가리키는 메모리 주소 3001은 변함이 없다.이를 가변 데이터라고 하는 것이다.변수 obj01과 obj02는 같은 참조 값을 가지므로 같은 객체를 가리키고 객체의 프로퍼티가 업데이트되면 같은 객체를 가리키므로 10~11번 줄과 같이 같은 값이 출력된다.각주 HowToCreateApps, Mutable and Immutable Types in JavaScript (With Examples)" }, { "title": "JavaScript - 가비지 컬렉션(Garbage Collection)", "url": "/posts/javascript-garbage-collection/", "categories": "Programming, JavaScript", "tags": "javascript, garbage collection, garbage collector, garbage collection algorithm, reference counting, circular reference, mark-and-sweep, managing memory, memory leaks, 자바스크립트, 가비지 컬렉션, 가비지 컬렉터, 가비지 컬렉션 알고리즘, 참조 카운팅, 순환 참조, 표시하고 지우기, 메모리 관리, 메모리 누수", "date": "2021-08-14 23:55:00 +0900", "snippet": "가비지 컬렉션자바스크립트는 실행 환경에서 코드를 실행하는 중에 메모리를 관리하는데, 개발자가 직접 메모리를 관리하지 않아도 자바스크립트는 필요한 메모리를 할당하고 더 이상 사용하지 않는 메모리는 회수한다.예를 들어, 함수 내에 선언된 지역 변수는 함수를 실행할 때 생성된다.이 지역 변수는 함수의 실행이 마치면 더 이상 사용하지 않게 되고 가비지 컬렉터가 이를 추적해 해당 변수가 차지하고 있던 메모리를 회수한다.var obj = { key: &#39;value&#39;};변수 obj는 {key: value} 객체가 저장된 메모리를 가리키는 참조 값을 갖는다.이 객체가 차지하고 있는 메모리 공간을 변수 obj가 참조하고 있는 한 가비지 컬렉터는 메모리를 회수하지 않는다.하지만 다음과 같은 경우 가비지 컬렉터는 이 객체를 더 이상 사용하지 않는 객체로 판단하고 메모리를 회수한다.obj = null;변수 obj에 null을 할당했으므로 변수 obj는 객체가 저장된 메모리를 가리키는 참조 값을 잃게 된다.이때 어디에서도 이 객체를 참조하고 있지 않다면 가비지 컬렉터는 메모리에 저장된 객체를 더 이상 사용하지 않는 값으로 판단하고 메모리를 회수한다.가비지 컬렉터가 가비지 컬렉션을 수행하는 방법에는 다양한 가비지 컬렉션 알고리즘이 존재한다.널리 쓰이는 기본적인 가비지 컬렉션 알고리즘엔 Mark-and-Sweep이 있으며, 그 외에 Reference Counting 등이 있다.가비지 컬렉션 알고리즘은 브라우저마다 다르다.가비지 컬렉션 알고리즘Reference Counting참조 카운팅 방식은 메모리에 저장된 값이 얼마나 참조되었는지를 추적한다.변수를 선언하고 참조 값이 할당되면 참조 카운트는 1이 된다.다른 변수가 같은 값을 참조하고 있다면 참조 카운트는 1 증가한다. 만약 이 변수에 다른 값을 할당하거나 참조 값을 제거하면 원래 참조하고 있던 값의 참조 카운트가 1 감소한다.값의 참조 카운트가 0이 되면 해당 값에 접근할 방법이 없으므로 가비지 컬렉터는 이 메모리를 회수한다.function outerFn() { var objA = {}; // objA RC 1 function innerFn() { var objB = {} // objB RC 1 objA.ref = objB; // objB RC 2 } innerFn(); // objB RC 1}outerFn();// objA RC 0, objB RC 0outerFn 함수 안에 objA 변수를 선언하고 빈 객체를 할당해 초기화했다. 이때 변수 objA의 참조 카운트는 1이 된다.innerFn 함수 안에는 objB 변수를 선언하고 빈 객체를 할당해 초기화했다. 그리고 objA의 프로퍼티에 objB를 할당해 objA.ref가 objB를 참조하도록 했다. objB와 objA.ref가 같은 객체를 참조하고 있으므로 objB의 참조 카운트는 2가 된다.innerFn 함수의 실행이 마치면 변수 objB는 스코프를 벗어나게 되고, 더이상 사용할 수 없으므로 참조 카운트는 1 감소한다.outerFn 함수의 실행이 마치면 변수 objA도 스코프를 벗어나게 되고, 더이상 사용할 수 없으므로 참조 카운트는 0이 된다.변수 objA의 참조 카운트가 0이 되면서 objA.ref로 참조하던 변수 objB를 더이상 참조할 수 없게되고 objB의 참조 카운트도 0이 된다.가비지 컬렉터는 참조 카운트가 0이 된 두 객체를 더이상 사용하지 않는 것으로 판단하고 메모리를 회수하게 된다.순환 참조참조 카운팅 방식에서 순환 참조는 메모리 누수의 원인이 된다.function circularRef() { var objA = {}; // objA RC 1 var objB = {}; // objB RC 1 objA.ref = objB; // objB RC 2 objB.ref = objA; // objA RC 2}circularRef(); // objA RC 1, objB RC 1circularRef 함수를 실행하면 변수 objA와 objB가 선언되고 참조 값이 할당되면서 각각 참조 카운트가 1 증가한다.그리고 objA와 objB는 프로퍼티를 통해 서로를 참조하고 있다.이때 참조 카운트가 1 증가하면서 각각의 참조 카운트는 2가 된다.함수 실행을 마치면 두 변수 모두 스코프를 벗어났음에도 참조 카운트가 0이 되지 않기 때문에 가비지 컬렉터는 메모리를 회수하지 않는다.만약 이 함수가 여러번 호출되면 회수하지 못하고 낭비하는 메모리가 늘어난다.Mark-and-Sweepmark-and-sweep 방식은 roots라는 최상위 객체에서 시작해서 도달할 수 없는 객체에 대해 가비지 컬렉션을 수행한다.var globalA = &#39;A&#39;;var globalB = &#39;B&#39;;var globalC = { refGlobalA: globalA;}function globalFn() { var localA = &#39;a&#39;; var localB = &#39;b&#39;; globalC.refLocalA = localA;}globalFn();가비지 컬렉터가 동작하면 먼저 메모리에 저장된 모든 변수에 표시를 남긴다.그다음 roots에 속하는 globalA, globalB, globalC, globalFn부터 도달 가능한 모든 객체를 탐색하며 표시를 지운다.위 코드에서 globalFn 함수의 실행이 마치면 지역 변수 localA는 globalC.refLocalA를 통해 roots로부터 도달할 수 있지만 변수 localB에는 더이상 도달할 수 없게되고 표시가 남아있게 된다.가비지 컬렉터는 변수 localB를 더이상 사용하지 않는 값으로 판단하고 메모리를 회수한다.이런 방식은 참조 카운팅 방식의 순환 참조 문제를 해결한다.메모리 관리웹 브라우저 환경에서 사용할 수 있는 메모리는 일반적인 데스크톱 애플리케이션의 가용 메모리에 비해 매우 적은 편이다.웹 브라우저가 적은 양의 가용 메모리를 할당받는 주된 이유는 웹 페이지에서 실행하는 자바스크립트가 시스템 메모리를 전부 사용해서 운영체제가 다운되는 일을 방지하기 위함이다.이러한 메모리의 제한은 변수 할당뿐만 아니라 호출 스택, 스레드에서 실행할 수 있는 문장 수에도 영향을 미친다.이런 환경에서 웹 페이지의 성능을 최대한으로 향상시킬 수 있는 방법은 코드 실행에 필요한 데이터만 유지하는 것이다.더 이상 사용하지 않는 데이터에 null을 할당해서 참조를 제거하는 것이 좋다.지역 변수 같은 경우 컨텍스트를 벗어나면 자동으로 참조가 제거되기 때문에 명시적으로 참조를 제거해줄 필요가 없다.변수의 참조를 제거한다고 해서 메모리가 자동으로 반환되는 것은 아니다.참조 제거의 요점은 값의 컨텍스트를 없애서 가비지 컬렉터가 이를 추적해 메모리를 회수하도록 하는 것이다.각주 Nicholas C. Zakas(2012), “JavaScript for Web Developers” JAVASCRIPT.INFO, 가비지 컬렉션 MDN Web Docs, 자바스크립트의 메모리관리" }, { "title": "JavaScript - DOM(The Document Object Model)", "url": "/posts/javascript-dom/", "categories": "Programming, JavaScript", "tags": "javascript, the document object model, dom level 1, hierarchy of nodes, the node type, the document type, the element type, the text type, the attr type, node-list object, 자바스크립트, 문서 객체 모델, dom 레벨 1, 노드의 계층 구조, node 타입, document 타입, element 타입, text 타입, attr 타입, node-list 객체", "date": "2021-08-07 02:50:00 +0900", "snippet": "노드 계층 구조웹 페이지는 일종의 문서이며, 웹브라우저 호스트 환경에선 DOM을 문서에 엑세스하고 조작하기 위한 API로 사용한다.DOM을 통해 개발자는 페이지의 각 부분을 추가하거나 제거, 수정할 수 있다.DOM은 문서를 노드의 계층 구조로 표현하며, 자료구조에서 트리 구조와 같다.노드에는 여러 타입이 있는데 각 노드 타입엔 서로 다른 데이터, 메서드가 있다.노드의 계층 구조를 마크업과 다이어그램으로 표현하면 다음과 같다.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;Gunn’s Blog&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Blog&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt; &amp;lt;em&amp;gt;Greeting: &amp;lt;/em&amp;gt; Hello! &amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;DOM TreeDocument 노드는 각 문서의 루트이며 자식 노드로 html 요소 하나를 갖는다.html 요소는 모든 요소의 최상위 요소이다.Node 타입DOM 레벨 1에는 Node라는 인터페이스가 있으며 모든 노드 타입은 Node 인터페이스를 구현한다.노드 타입엔 12가지 타입이 있으며 각 타입은 숫자형 상수로 나타낸다. 이 상수는 Node 타입에 정의되어 있다.Node.ELEMENT_NODE; // 1Node.ATTRIBUTE_NODE; // 2Node.TEXT_NODE; // 3Node.DOCUMENT_NODE; // 9// ...Node의 프로토타입에는 nodeType 프로퍼티가 있다.nodeType 프로퍼티를 사용해 요소의 노드 타입을 확인할 수 있다.document.nodeType == Node.DOCUMENT_NODE; // true노드의 이름, 값 확인nodeName과 nodeValue 프로퍼티를 사용해 노드의 정보를 알 수 있다. 노드 타입별로 반환하는 값은 완전히 다르다.요소 노드와 속성 노드, 텍스트 노드에 nodeName과 nodeValue 프로퍼티를 사용했을 때 반환하는 값은 다음과 같다.- HTML&amp;lt;nav class=&quot;gnb&quot; role=&quot;navigation&quot;&amp;gt; &amp;lt;ul class=&quot;gnb__list&quot;&amp;gt; &amp;lt;li class=&quot;gnb__item gnb__item--home&quot;&amp;gt;HOME&amp;lt;/li&amp;gt; &amp;lt;li class=&quot;gnb__item&quot;&amp;gt;CATEGORIES&amp;lt;/li&amp;gt; &amp;lt;li class=&quot;gnb__item&quot;&amp;gt;TAGS&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt;&amp;lt;/nav&amp;gt;- JavaScriptvar gnb = document.querySelector(&#39;.gnb&#39;);var gnbItemHome = document.querySelector(&#39;.gnb__item--home&#39;);console.log(gnb.nodeType); // 1console.log(gnb.nodeName); // NAVconsole.log(gnb.nodeValue); // nullconsole.log(gnb.attributes); // NameNodeMap {0: class, 1: role, ...}console.log(gnb.attributes[1].nodeType); // 2console.log(gnb.attributes[1].nodeName); // roleconsole.log(gnb.attributes[1].nodeValue); // navigationconsole.log(gnbItemHome.childNodes[0].nodeType); // 3console.log(gnbItemHome.childNodes[0].nodeName); // #textconsole.log(gnbItemHome.childNodes[0].nodeValue); // HOME Node Type nodeName nodeValue Element Node 태그 이름을 반환하며 데이터 타입은 문자열이다. 모든 요소 노드의 nodeValue 값은 null이다. Attribute Node 속성명을 반환하며 데이터 타입은 문자열이다. 속성 값을 반환한다. Text Node #text를 반환하며 데이터 타입은 문자열이다. 문자열을 반환한다. NodeList 객체각 노드에는 childNodes 프로퍼티가 존재하며, 이 프로퍼티에는 NodeList 객체가 있다.NodeList 객체는 노드의 컬렉션으로 자식 노드를 배열 형태로 저장하는데 대괄호 표기법으로 자식 노드에 접근할 수 있다.NodeList 객체는 배열과 같이 length 프로퍼티로 자식 노드의 개수를 알아내거나 forEach 메서드로 자식 노드를 순회하며 함수를 실행할 수 있다. 단, NodeList는 Array의 인스턴스는 아니다.NodeList는 DOM 구조에 대한 쿼리 결과이며 DOM이 수정되면 실시간으로 NodeList에 반영된다.var gnbList = document.querySelector(&#39;.gnb__list&#39;);var gnbChildNodes = gnbList.childNodes;console.log(gnbChildNodes); // NodeList(7) [text, li.gnb__item.gnb__item--home, ...]var li = document.createElement(&#39;li&#39;);gnbList.appendChild(li);console.log(gnbChildNodes); // NodeList(8) [text, li.gnb__item.gnb__item--home, ..., li]gnbList의 자식 노드 컬렉션 정보를 갖고 있는 NodeList 객체를 gnbChildNodes 변수에 할당했다.li 요소를 생성하고 appendChild 메서드를 사용해 gnbList의 자식 노드로 li 요소를 추가했다.gnbChildNodes 변수에 저장된 NodeList 객체의 노드 개수가 7개에서 8개로 실시간 반영된 것을 확인할 수 있다. 💡 ul 요소의 자식 요소에 텍스트 노드가 있는 이유는?코드의 가독성을 위해 줄바꿈을 하면 이스케이프 문자 \\n을 입력한 것으로 판단하기 때문에 텍스트 노드를 자식 노드로 갖게 된다.children 프로퍼티와 childNodes 프로퍼티children 프로퍼티는 childNodes 프로퍼티와 달리 HTMLCollection 객체를 반환한다.HTMLCollection 객체는 children 프로퍼티를 호출한 요소의 모든 자식요소를 포함한다.즉, TEXT_NODE, COMMENT_NODE와 같은 비요소는 포함하지 않는다.HTMLCollection 객체 역시 NodeList 객체와 같이 라이브 객체이기 때문에 DOM의 변화에 따라 실시간으로 반영한다.노드 사이의 관계모든 노드에는 부모, 자식, 형제 노드에 접근할 수 있는 프로퍼티가 존재한다.var gnbList = document.querySelector(&#39;.gnb__list&#39;);console.log(gnbList.childNodes) // NodeList(7) [text, li.gnb__item.gnb__item--home, text, li.gnb__item, text, li.gnb__item, text]console.log(gnbList.childNodes[0].parentNode) // &amp;lt;ul class=&quot;gnb__list&quot;&amp;gt;...&amp;lt;/ul&amp;gt;console.log(gnbList.childNodes[0].nextSibling) // &amp;lt;li class=&quot;gnb__item gnb__item--home&quot;&amp;gt;...&amp;lt;/li&amp;gt;console.log(gnbList.childNodes[0].previousSibling) // nullconsole.log(gnbList.firstChild) // #textconsole.log(gnbList.lastChild) // #textgnbList 노드의 자식 노드에는 총 7개의 자식 노드가 존재한다.gnbList 노드의 자식 노드에 parentNode 프로퍼티를 사용하면 모두 gnbList 노드를 반환한다.gnbList 노드의 자식 노드 간에 관계를 가리키는 프로퍼티로 nextSibling와 previousSibling 프로퍼티가 있으며, 이전 또는 다음 노드가 존재하지 않으면 null 값을 반환한다.자식 노드 중 첫 번째 노드와 마지막 노드를 가리키는 프로퍼티에는 firstChild와 lastChild 프로퍼티가 있다.비요소 노드를 제외한 요소 노드에만 접근하는 프로퍼티는 다음과 같다.parentElement, nextElementSibling, previousElementSibling, firstElementChild, lastElementChild 프로퍼티를 사용한다.노드 조작appendChild 메서드appendChild 메서드는 NodeList 객체의 마지막 노드에 새로운 노드를 추가하고 새로 추가한 노드를 반환한다.appendChild 노드를 실행하면 새로 추가한 노드, 부모 노드, 새로 추가한 노드의 이전 노드의 모든 관계 포인터가 업데이트된다.var returnedNode = someNode.appendChild(newNode);console.log(returnedNode == newNode); // trueconsole.log(someNode.lastChild == newNode) // true1번 줄에서는 someNode의 자식노드로 newNode를 추가하고 appendChild 메서드가 반환한 새로 추가한 노드를 변수 returnedNode에 저장했다.2번 줄에서 newNode와 appendChild 메서드가 반환한 값을 비교하면 true이다.3번 줄에서는 새로 추가한 노드가 someNode의 마지막 자식 노드와 같음을 알 수 있다.만약 appendChild 메서드의 인자로 넘겨진 노드가 document에 이미 존재하는 노드를 참조하고 있다면 해당 노드는 현재 위치에서 새로운 위치로 이동한다.DOM 트리에 수많은 노드가 포인터로 연결되어 있지만 노드가 동시에 두 위치에 존재할 수는 없기 때문이다.var returnedNode = someNode.appendChild(someNode.firstChild);console.log(returnedNode == someNode.firstChild); // falseconsole.log(returnedNode == someNode.lastChild) // true1번 줄에서 someNode의 마지막 자식 노드로 someNode의 첫 번째 자식 노드를 추가하는 appendChild 메서드를 실행하고 반환한 노드를 변수 returnedNode에 저장했다.2번 줄에서 returnedNode와 someNode.firstChild 노드를 비교했지만 결과는 false이다. someNode.firstChild 노드를 복사했기 때문에 returnedNode와 다른 참조 값을 가져 결과가 false가 되었다고 생각할 수 있지만 3번 줄의 코드 실행 결과를 보면 returnedNode와 someNode.lastChild 노드가 같은 노드인 것과 기존의 someNode.firstChild 노드가 마지막 노드로 위치가 바뀐 것을 알 수 있다.somdeNode 노드에 childNodes 프로퍼티를 사용하면 그 결과를 명확히 확인해 볼 수 있다.insertBefore 메서드특정 부모 노드에 insertBefore 메서드를 호출하면 인자로 넘긴 노드를 해당 부모 노드의 자식 노드로 삽입할 수 있다.insertBefore 메서드에 두 개의 인자를 전달하며 첫 번째 인자에는 삽입할 노드를 입력하고 두 번째 인자에는 삽입할 노드가 자식 노드의 몇 번째에 위치할지 결정할 기준 노드를 입력한다. 삽입할 노드는 기준 노드의 previousSibling 노드가 된다.두 번째 인자에 null을 전달하면 appendChild 메서드와 같이 마지막 자식 노드로 삽입한다.insertBefore 메서드는 실행 후에 삽입한 노드를 반환한다.var returnedNode = parentNode.insertBefore(nodeToInsert, null)console.log(parentNode.lastChild == returnNode) // true1번 줄에선 parentNode의 자식 노드로 nodeToInsert 노드를 삽입한다.insertBefore 메서드의 두 번째 인자로 null을 전달했기 때문에 삽입할 노드는 parentNode의 마지막 자식 노드가 되며, insertBefore 메서드의 실행 결과로 삽입한 노드가 변수 returnedNode에 저장되었다.insertBefore 메서드를 실행해 삽입하는 노드는 메서드를 호출하는 부모 노드가 DOM 트리에서 어느 depth에 있느냐에 따라 이동이 자유롭다.예를 들어 DOM 트리에서 가장 깊은 depth에 있는 노드를 body 요소의 첫 번째 자식 요소로 삽입할 수 있다.replaceChild 메서드replaceChild 메서드는 특정 부모 노드의 자식 노드를 다른 노드로 교체한다.replaceChild 메서드에 두 개의 인자를 전달하며 첫 번째 인자에는 교체할 새로운 노드를 입력하고 두 번째 인자에는 교체될 노드를 입력한다.교체되는 노드는 DOM 트리에서 제거되며 replaceChild 메서드 실행이 마치면 교체된 노드를 반환한다.교체된 노드가 DOM 트리에서 제거 됐다고 해서 최상위 노드인 document의 소유에서 완전히 제거된 것은 아니다.var gnbList = document.querySelector(&#39;.gnb__list&#39;);var gnbItemHome = document.querySelector(&#39;.gnb__item--home&#39;);var li = document.createElement(&#39;li&#39;);li.textContent = &#39;HOMEPAGE&#39;;console.log(gnbList.replaceChild(li, gnbList.firstElementChild)) // &amp;lt;li class=&quot;gnb__item gnb__item--home&quot;&amp;gt;HOME&amp;lt;/li&amp;gt;console.log(gnbItemHome.parentNode) // nullconsole.log(gnbItemHome.ownerDocument) // #document7번 줄에서 gnbList의 첫 번째 자식 요소를 새로 생성한 li 요소로 대체했다.replaceChild 메서드의 실행 결과로 대체된 기존 요소가 반환된 것을 알 수 있다.8번 줄에서 기존에 존재하던 gnbList의 첫 번째 자식 요소가 새로운 노드로 대체되면서 부모 노드가 null이 됐다.하지만 gnbItemHome 노드의 최상위 노드가 여전히 document 노드인 것을 확인할 수 있다.removeChild 메서드removeChild 메서드는 하나의 인자만 전달 받으며 메서드를 호출한 노드의 자식 노드 중 인자로 전달한 노드를 제거한다.replaceChild 메서드와 마찬가지로 removeChild 메서드로 제거한 노드는 DOM 트리에서만 제거 됐을 뿐 여전히 document 노드를 최상위 노드로 가리킨다.console.log(gnb.removeChild(gnb.firstElementChild)) // &amp;lt;ul class=&quot;gnb__list&quot;&amp;gt;...&amp;lt;/ul&amp;gt;cloneNode 메서드cloneNode 메서드는 메서드를 호출한 노드를 복제하고 복제된 노드를 반환한다.cloneNode 메서드는 boolean 타입의 인자 하나를 전달 받으며 true이면 자손 노드 전체를 복제하고 인자를 전달하지 않거나 false를 전달하면 해당 노드 하나만 복제한다.복제된 노드는 부모 노드가 없기 때문에 appendChild 메서드와 같은 메서드로 DOM 트리에 추가해야 한다.var dupNode = gnbList.cloneNode(true);console.log(dupNode); // &amp;lt;ul class=&quot;gnb__list&quot;&amp;gt;...&amp;lt;/ul&amp;gt;console.log(dupNode.parentNode); // null각주 Nicholas C. Zakas(2012), “JavaScript for Web Developers” DOM Standard, Old-style collections: NodeList and HTMLCollection" }, { "title": "JavaScript - 객체 지향 프로그래밍(Object-Oriented Programming)", "url": "/posts/javascript-object-oriented-programming/", "categories": "Programming, JavaScript", "tags": "javascript, object-oriented programming, types of properties, property descriptors, data property descriptor, accessor property descriptor, data property, accessor property, object creation, the constructor pattern, the prototype pattern, prototype, inheritance, 자바스크립트, 객체 지향 프로그래밍, 프로퍼티 타입, 디스크립터 프로퍼티, 데이터 속성 서술자, 접근자 속성 서술자, 데이터 속성, 접근자 속성, 객체 생성, 생성자 패턴, 프로토타입 패턴, 프로토타입, 상속", "date": "2021-08-01 19:15:00 +0900", "snippet": "프로퍼티 타입객체 프로퍼티의 각 속성은 두 가지 타입의 특별한 프로퍼티 디스크립터(property descriptors)를 갖는 데, 이는 객체 프로퍼티의 각 속성을 조작하는 데 사용한다.디스크립터는 JS 엔진 내부에서 구현하는 것으로 자바스크립트에서 직접적으로 접근할 수는 없다. ECMAScript 원문에는 객체의 키(key)와 값(value)을 한 쌍으로 하는 데이터의 집합을 지칭할 땐 ‘Properties’로 쓰고 단일 프로퍼티를 지칭할 때는 ‘Attributes’를 쓴다. 한글로 번역하면 두 단어 모두 ‘속성’이지만 본문에서는 이를 구분하기 위해 ‘Properties’는 ‘프로퍼티’로 쓰고 ‘Attributes’는 ‘속성’으로 썼다.데이터 프로퍼티 디스크립터데이터 디스크립터에는 네 가지 속성(attributes)이 있다. 속성명 데이터 타입 설명 [[Configurable]] Boolean 객체 프로퍼티를 delete 연산자로 제거하거나, 디스크립터의 속성을 변경하거나, 엑세서 디스크립터로 변경 가능 여부를 나타낸다.속성 값이 false 일 경우 예외적으로 [[Value]] 값은 변경할 수 있다. [[Writable]] 값도 변경할 수 있지만 true에서 false로 한 번만 변경 가능하다.[[Configurable]] 속성 값은 false로 설정하면 다시는 수정할 수 없다. [[Enumerable]] Boolean for-in문에서 객체 프로퍼티의 열거 여부를 나타내며, flase이면 해당 프로퍼티를 열거하지 않는다. [[Writable]] Boolean 객체 프로퍼티의 값 변경 가능 여부를 나타내며 false이면 값을 바꿀 수 없다. [[Vlaue]] Any type 객체 프로퍼티의 실제 값 var person = { name: &#39;Gunn&#39;, age: 30, getName() { console.log(this.name); }};Object.defineProperty(person, &#39;name&#39;, { writable: false});person.name = &#39;Jun&#39;;console.log(person.name); // GunnObject.defineProperty 메서드는 객체에 새로운 프로퍼티를 정의하거나 기존 프로퍼티의 디스크립터 속성 값을 변경하고 그 객체를 반환한다.첫 번째 인수는 객체를. 두 번째 인수는 속성명을. 세 번째 인수는 디스크립터를 넘긴다.위 코드에서 name의 데이터 디스크립터 속성 중 writable 속성 값을 false로 설정했다.person 객체 name의 속성 값을 Jun으로 할당했지만 값은 바뀌지 않았다. 🧐 Object.defineProperty 메서드를 사용해 새로운 프로퍼티를 정의할 때 디스크립터 속성 값을 명시적으로 설정하지 않으면 초기 값은 false가 된다.value는 undefined를 초기 값으로 할당한다.객체의 특정 프로퍼티를 선택해 디스크립터 객체의 각 속성 값을 확인하는 방법은 아래와 같다.Object.getOwnPropertyDescriptor(person, &#39;name&#39;);// 반환된 디스크립터 객체{ value: &#39;Gunn&#39;, configurable: true, enumerable: true, writable: false}Object.getOwnPropertyDescriptor 메서드는 객체의 특정 프로퍼티의 디스크립터 객체를 반환한다.첫 번째 인수로 객체를 넘기고 두 번째 인수로 해당 객체에서 찾을 속성명을 넘긴다.엑세서 프로퍼티 디스크립터엑세서 디스크립터에는 네 가지 속성(attributes)이 있다.엑세서 디스크립터는 데이터 디스크립터와 달리 value와 enumerable 속성이 없는 대신에 get과 set 함수가 있다.get 함수는 객체 프로퍼티를 읽을 때 실행되고, set 함수는 객체 프로퍼티에 값을 할당할 때 실행된다. 속성명 데이터 타입 설명 [[Configurable]] Boolean 객체 프로퍼티를 delete 연산자로 제거하거나, 디스크립터의 속성을 변경하거나, 데이터 디스크립터로 변경 가능 여부를 나타낸다.[[Configurable]] 속성 값은 false로 설정하면 다시는 수정할 수 없다. [[Enumerable]] Boolean for-in문에서 객체 프로퍼티의 열거 여부를 나타내며, flase이면 해당 프로퍼티를 열거하지 않는다. [[Get]] Object 프로퍼티를 읽을 때 호출할 매서드로 매개변수가 없다. [[Set]] Object 프로퍼티 값을 변경할 때 호출할 메서드로 하나의 매개변수가 있다. let person = { _lastName: &#39;Gunn&#39;, firstName: &#39;Kim&#39;, get name() { return `${this._lastName} ${this.firstName}`; }, set name(newValue) { if(this._lastName != newValue) { return this._lastName = newValue; } alert(&#39;현재 이름과 다른 이름을 입력하세요.&#39;); }}person.name; // Gunn Kimperson.name = &#39;Jun&#39;; // Junperson.name; // Jun Kim엑세서 디스크립터의 get 메서드와 set 메서드는 Object.defineProperty 메서드를 사용해 정의해도 되지만, 객체를 생성할 때 함께 정의할 수도 있다.위 코드에서 person.name으로 프로퍼티를 읽을 때 get 메서드가 호출되며, 메서드 몸체에 정의한 구문을 실행한다.set 메서드는 17번 줄의 person.name = &#39;Jun&#39;;와 같이 프로퍼티에 값을 할당할 때 호출되며, 할당한 값을 매개변수로 받아 set 메서드를 실행한다. 💡 Tip단일 프로퍼티 정의 또는 단일 프로퍼티 읽기가 아닌 복합적으로 프로퍼티를 정의하거나 읽을 수 있는 메서드가 있다.Object.defineProperties 메서드는 여러 프로퍼티를 한 번에 정의할 수 있고, Object.getOwnPropertyDescriptors 메서드는 여러 프로퍼티를 한 번에 읽을 수 있다.생성자 함수와 get 메서드와 set 메서드를 활용하면 인스턴스마다 고유한 값을 만들어 내는 동작을 실행할 수 있다.function Person(name, _birthday) { this.name = name; this._birthday = new Date(_birthday); Object.defineProperty(this, &#39;age&#39;, { get() { return new Date().getFullYear() - this._birthday.getFullYear(); } });}let person1 = new Person(&#39;Jun&#39;, &#39;1999.1.21&#39;);person1.age;위 코드는 Person의 인스턴스를 생성할 때 age 프로퍼티를 정의하고 get 메서드를 지정했다.person1 인스턴스의 age 프로퍼티를 읽으면 get 메서드가 호출되어 사람의 나이를 알 수 있다.객체 생성생성자 패턴과 프로토타입 패턴의 조합function Person(name, age) { this.name = name; this.age = age;}Person.prototype = { constructor: Person, getName: function() { console.log(this.name); }}var person1 = new Person(&#39;Gunn&#39;, 30);var person2 = new Person(&#39;Jun&#39;, 27);person1.getName(); // Gunnperson2.getName(); // Junconsole.log(person1.getName == person2.getName); // true생성자 패턴을 사용하면 생성자 호출 시 매개변수에 값을 전달해 인스턴스마다 고유의 프로퍼티 값으로 초기화 할 수 있고, 프로토타입 패턴을 사용하면 모든 인스턴스가 공유하는 프로퍼티와 메서드를 정의할 수 있다.각주 Nicholas C. Zakas(2012), “JavaScript for Web Developers” ECMAScript® 2022 Language Specification, The Object Type JAVASCRIPT.INFO, 프로퍼티 getter와 setter MDN Web Docs, Object prototypes" }, { "title": "JavaScript - 참조 타입 &amp; 함수 타입(Reference Types &amp; Function Type)", "url": "/posts/javascript-reference-types-and-function-type/", "categories": "Programming, JavaScript", "tags": "javascript, reference types, function type, function declarations versus function expressions, function properties and methods, name property, length property, prototype property, custom properties, apply method, call method, bind method, 자바스크립트, 참조 타입, 함수 타입, 함수 선언 vs 함수 표현식, 함수 프로퍼티와 메서드, name 프로퍼티, length 프로퍼티, prototype 프로퍼티, 커스텀 프로퍼티, apply 메서드, call 메서드, bind 메서드", "date": "2021-07-24 04:45:00 +0900", "snippet": "Function 타입ECMAScript에서 함수는 객체이다.모든 함수는 Function 타입의 인스턴스이며 객체와 마찬가지로 프로퍼티와 메서드가 있다.함수의 이름은 단순히 함수 객체를 가리키는 포인터 역할을 할 뿐이다.function greetings(name) { console.log(`Hello! ${name}.`);}let greet = greetings;greet(&#39;Gunn&#39;); // &quot;Hello! Gunn.&quot;greetings = null;greet(&#39;Gunn&#39;); // &quot;Hello! Gunn.&quot;greetings 함수를 생성하고 변수 greet에 greetings 함수를 대입했다.greetings 함수의 이름은 함수 정의가 저장된 메모리를 가리키는 포인터이기 때문에 변수 greet는 greetings와 같은 참조 값을 갖는다.그러므로 greetings와 greet는 같은 함수 객체를 가리킨다.8번 줄에서 greetings에 null을 할당하면 함수 객체를 가리키는 참조가 제거되지만 greet에는 영향이 없다.함수 선언 vs 함수 표현식함수 선언문과 함수 표현식의 가장 큰 차이는 JS 엔진이 함수를 생성하는 시점에 있다. 이를 이해하기 위해서는 실행 컨텍스트의 개념을 알고 있어야 한다.함수 선언은 코드를 실행하기 전에 모든 실행 컨텍스트에서 접근하고 실행할 수 있지만 함수 표현식은 코드 실행이 해당 줄까지 진행하기 전에는 사용할 수 없다.sum(5, 10); // 15function sum(num1, num2) { console.log(num1 + num2)}JS 엔진이 코드를 스캔하면 가장 먼저 변수와 함수 선언을 찾는데, 이때 함수 선언 호이스팅이란 과정을 통해 함수 선언을 실행 컨텍스트에 추가한다.실행 컨텍스트의 생성 단계에서 이미 함수 선언 호이스팅이 발생하기 때문에 소스 코드에서 함수 실행이 함수 선언보다 먼저 작성되어 있어도 에러를 내지 않는다.하지만 함수 표현식은 함수 선언이 아닌 변수 선언 이후 초기화 문장에 해당하기 때문에 소스 코드에서 함수 실행이 함수 표현식보다 먼저 작성될 경우 에러가 발생한다.sum(5, 10); // Errorlet sum = function(num1, num2) { console.log(num1 + num2)}use strict 모드에서 함수 선언&#39;use strict&#39;let age = prompt(&#39;나이를 입력하세요&#39;);if(age &amp;lt; 20) { function greeting() { console.log(&#39;Hello!&#39;); }} else { function greeting() { console.log(&#39;Hi!&#39;); }}greeting(); // Errorstrict mode에서 코드 블록 내에 함수 선언문이 있는 경우 코드 블록 외부에선 함수에 접근이 불가능하다.함수 프로퍼티와 메서드ECMAScript의 함수는 객체이므로 프로퍼티와 메서드를 가진다.모든 함수에는 공통적으로 name, length, prototype 프로퍼티가 있다.함수 공통 프로퍼티- name 프로퍼티name 프로퍼티를 사용해 함수의 이름을 알 수 있다.function sayName() { console.log(name);}console.log(sayName.name); // &quot;sayName&quot;함수 표현식으로 정의된 함수에도 사용할 수 있다.let sayName = function() { console.log(name);}console.log(sayName.name); // &quot;sayName&quot;익명 함수에 name 프로퍼티를 사용하면 빈 문자열을 반환한다.(function(){}).name; // &quot;&quot;객채 메서드의 이름도 name 프로퍼티를 사용해 알 수 있다.let person = { name: &#39;Gunn&#39;, getName: function() { console.log(this.name); }}console.log(person.getName.name); // &quot;getName&quot;객체에 constructor 프로퍼티와 name 프로퍼티를 사용하면 객체의 class를 알 수있다.function person() {}let student = new person();console.log(student.constructor.name); // person- length 프로퍼티length 프로퍼티를 사용해 함수 매개변수의 개수를 알 수 있다.function sayName(lastName, firstName) { console.log(`${lastName} ${firstName}`);}console.log(sayName.length); // 2- 커스텀 프로퍼티사용자가 직접 프로퍼티를 생성해 함수에 추가할 수 있다.function sayName(lastName, firstName) { console.log(`${lastName} ${firstName}`); sayName.counter++;}sayName.counter = 0;sayName(&#39;Gunn&#39;, &#39;Kim&#39;); // &quot;Gunn Kim&quot;console.log(`호출 횟수: ${sayName.counter}회`); // 호출 횟수: 1회💡 프로퍼티는 변수가 아니다sayName.counter = 0;는 함수 내에 지역 변수의 선언이 아닌 프로퍼티이다.let counter;와는 관계가 없다.함수 메서드함수에는 apply와 call, bind 메서드가 있다.apply와 call 메서드는 함수 호출 시 함수 내부의 this 객체 값을 바꾸거나 매개변수를 전달할 수 있다.- apply 메서드 apply 문법 func.apply(thisArg, [argsArray])const person = { lastName: &#39;Gunn&#39;, firstName: &#39;Kim&#39;}function getName(lastName, firstName) { console.log(`${this.lastName} ${this.firstName}`);}getName.apply(person, [&#39;Gunn&#39;, &#39;Kim&#39;]); // Gunn KimgetName 함수는 전역에 선언되었으므로 함수 내부에 this는 window 객체를 가리킨다. strict mode에서는 apply나 call 메서드를 사용해 명시적으로 this 값을 정하지 않으면 this는 undefined가 된다.getName 함수에 apply 메서드를 호출해서 this 값으로 사용할 person 객체와 매개변수로 사용할 배열을 넘겼다.이렇게 apply 메서드를 활용하면 객체마다 메서드를 정의하지 않아도 범용적으로 사용할 수 있다.두 번째 인자에는 Array의 인스턴스 뿐만 아니라 arguments 객체를 넘길 수도 있다.function sum() { let total = 0; for(arg of arguments) { total += arg; } return total;}function callSum() { return sum.apply(null, arguments);}callSum(5, 2, 10); // 17- call 메서드 call 문법 func.call(thisArg[, arg1[, arg2[, ...]]])call 메서드는 apply 메서드와 같은 동작을 하지만 매개변수를 전달하는 방식이 다르다.apply 메서드는 매개변수를 배열 또는 유사 배열 객체로 전달하는 데 반해 call 메서드는 각각의 매개변수를 콤마(,)로 구분해 나열한다.- bind 메서드 bind 문법 func.bind(thisArg[, arg1[, arg2[, ...]]])bind 메서드를 호출하면 새로운 함수 인스턴스를 생성한다.const person = { lastName: &#39;Gunn&#39;, firstName: &#39;Kim&#39;}const admin = { name: &#39;관리자&#39;}function getName(lastName, firstName) { if(arguments.length == 0) { return this.name } console.log(`${this.lastName} ${this.firstName}`);}let getAdmin = getName.bind(admin);getName.apply(person, [&#39;Gunn&#39;, &#39;Kim&#39;]); // Gunn KimgetAdmin(); // 관리자17번 줄에서 getName 함수에 bind 메서드를 호출하면서 admin 객체를 넘겼다.이때 원본 함수 getName 함수의 복제본이 반환되면서 새로운 함수 인스턴스를 생성한다.getAdmin 함수는 전역에서 호출을 하더라도 항상 admin 객체가 this 값이다.각주 Nicholas C. Zakas(2012), “JavaScript for Web Developers” JAVASCRIPT.INFO, 함수 표현식 JAVASCRIPT.INFO, 객체로서의 함수와 기명 함수 표현식 MDN Web Docs, Function.prototype.apply() MDN Web Docs, Function.prototype.call() MDN Web Docs, Function.prototype.bind()" }, { "title": "JavaScript - 실행 컨텍스트(Execution Context)", "url": "/posts/javascript-execution-context/", "categories": "Programming, JavaScript", "tags": "javascript, execution context and scope, execution context, scope, activation object, variable object, scope chain, this value, global execution context, execution phase, function execution context, creation phase, 자바스크립트, 실행 컨텍스트와 스코프, 실행 컨텍스트, 스코프, 활성화 객체, 변수 객체, 스코프 체인, this 값, 전역 실행 컨텍스트, 함수 실행 컨텍스트, 실행 컨텍스트의 생성 단계, 실행 컨텍스트의 실행 단계", "date": "2021-07-17 05:30:00 +0900", "snippet": "실행 컨텍스트실행 컨텍스트는 코드의 런타임 평가를 추적하는 데 사용한다.즉, 실행 컨텍스트는 자바스크립트 코드가 실행되는 환경을 말하며 코드 실행을 위해 필요한 정보를 담고 있다.실행 컨텍스트는 추상화된 개념이므로 코드로 직접 접근은 불가능하다. 실행 컨텍스트에는 변수 객체, 스코프 체인, this 값이 있다.실행 컨텍스트의 종류로는 전역 실행 컨텍스트, 함수 실행 컨텍스트가 있다. 실행 컨텍스트의 종류에는 Eval 실행 컨텍스트도 있다. eval 함수가 호출되면 자체적인 실행 컨텍스트를 갖지만 eval 함수의 사용을 권장하지 않으므로 서술하지 않았다.ECMAScript를 구현한 환경에 따라 전역 실행 컨텍스트를 부르는 이름이 다른데, 웹 브라우저에서는 window가 전역 실행 컨텍스트이며 전역으로 정의된 모든 변수와 함수는 window 객체의 프로퍼티와 메서드이다.파일이 웹 브라우저에 로드되면 기본적으로 전역 실행 컨텍스트를 생성한다.전역 실행 컨텍스트는 오직 한 개만 생성하며, 모든 것을 관리하는 환경으로 브라우저를 종료하거나 해당 페이지를 떠날 때까지 존재한다. JS 엔진은 싱글 스레드이므로 코드를 실행 하는 데 하나의 전역 환경만 가능하다.함수 실행 컨텍스트는 함수 호출 시마다 생성하며 각각의 함수 실행 컨텍스트는 함수 실행이 마치면 소멸한다. 이때 해당 컨텍스트에서 정의한 변수와 함수도 함께 소멸한다.실행 컨텍스트를 생성하면 각 실행 컨텍스트는 순차적으로 실행 컨텍스트 스택에 쌓이는데, 이 정보로 실행 컨텍스트를 추적한다.실행 컨텍스트 스택에 사용하는 자료구조는 LIFO(last in first out)이다.var a = &#39;one&#39;;function fnA() { var b = &#39;two&#39;; function fnB() { var c = &#39;three&#39; } fnB();}fnA();실행 컨텍스트 스택에서 실행 컨텍스트의 생성과 소멸 과정 가장 먼저 전역 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 추가한다. 전역 실행 컨텍스트에서 코드가 실행된다. 12번 줄에서 fnA 함수를 호출하면 fnA 함수 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 추가한다. fnA 함수 내에서 fnB 함수가 호출되면 컨트롤이 fnA에서 fnB로 넘어가는데, 이때 fnB 함수 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 추가한다. fnB 함수 실행을 마치면 fnB 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 제거하고 컨트롤을 이전 컨텍스트인 fnA 함수로 반환한다. 마찬가지로 fnA 함수의 실행이 마치면 fnA 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 제거하고 컨트롤은 전역 실행 컨텍스트로 반환한다. 모든 코드의 실행을 완료하면 실행 컨텍스트 스택에서 전역 실행 컨텍스트를 제거한다.실행 컨텍스트는 생성 단계와 실행 단계로 나뉘어 수행한다.실행 컨텍스트 - 생성 단계와 실행 단계생성 단계에서 JS 엔진은 함수를 호출하지만 실행하지는 않는다.이 단계에서 JS 엔진은 컴파일을 위해 코드를 스캔하고 다음 작업을 수행하며 실행 컨텍스트를 생성한다. ✓ 활성화 객체/변수 객체 생성 함수의 arguments, 변수 및 함수 선언에 관한 모든 정보를 포함한다. ✓ 스코프 체인 생성 활성화 객체/변수 객체를 생성한 후 스코프 체인을 초기화한다. 스코프 체인은 현재 함수의 변수 객체를 포함한 모든 상위 함수의 변수 객체와 전역 실행 컨텍스트의 변수 객체를 갖는다. ✓ this 값 결정 스코프 체인을 생성한 후 this 값을 초기화한다.🤖 예제 코드x = 10;var a = &#39;one&#39;;y = function() { var z = 20;}function fnA(param1) { var b = 2; a = 1; function fnB() { var c = &#39;three&#39;; } fnB();}fnA(70);생성 단계 - 전역 실행 컨텍스트위 예제 코드는 생성 단계에서 전역 실행 컨텍스트를 다음과 같이 생성한다.globalExecutionContextObj = { variableObj: { a: undefined, fnA: Pointer to the function definition }, scopeChain: [GEC variable object], this: window} 먼저 JS 엔진은 전역에 선언된 변수와 함수를 찾는다. 키워드가 없는 것은 함수나 변수 선언으로 판단하지 않기 때문에 변수 x는 변수 객체에 추가하지 않는다. 변수 a는 전역에 선언된 변수이므로 전역 실행 컨텍스트에서 변수 객체의 프로퍼티로 설정하고 undefined 값으로 초기화한다. 4번 줄에 변수 y 역시 키워드가 없기 때문에 변수 선언으로 판단하지 않고 무시힌다. JS 엔진이 8번 줄로 이동하면 JS 엔진은 fnA 함수 정의를 힙 메모리에 저장하고 이곳을 가리키는 포인터 값을 설정한다. 스코프 체인은 전역 실행 컨텍스트의 변수 객체 하나만 존재한다. 전역 실행 컨텍스트의 this 값은 window 객체로 결정한다.실행 단계 - 전역 실행 컨텍스트생성 단계를 마치면 JS 엔진이 코드를 다시 한번 스캔하며 변수 객체를 변수의 값으로 업데이트하고 코드를 실행한다.실행 단계에서 전역 실행 컨텍스트 객체는 다음과 같다.globalExecutionContextObj = { variableObj: { a: &#39;one&#39;, fnA: Pointer to the function definition, x: 10, y: Pointer to the function definition }, scopeChain: [GEC variable object], this: window} 먼저 JS 엔진은 변수 x가 변수 객체에 존재하지 않는 것을 확인하고 전역 컨텍스트 객체의 프로퍼티로 추가한 뒤 10으로 초기화한다. 변수 a는 변수 객체에 존재하므로 값을 one로 업데이트한다. 변수 y는 변수 객체에 존재하지 않으므로 전역 컨텍스트 객체의 프로퍼티로 추가한 뒤 y에 대입된 함수 정의를 힙 메모리에 저장하고 이곳을 가리키는 포인터 값을 설정한다.생성 단계 - 함수 실행 컨텍스트위 예제 코드는 생성 단계에서 함수 실행 컨텍스트를 다음과 같이 생성한다.fnAExecutionContextObj = { activationObj: { argumentsObj: { 0: param1, length: 1 }, pram1: 70, b: undefined, fnB: Pointer to the function definition }, scopeChain: [fnA variable object, GEC variable object], this: window} fnA 함수를 호출하면 JS 엔진은 다시 컴파일 단계에 들어가며 함수 실행 컨텍스트를 생성하기 위해 함수를 스캔한다. 컨텍스트가 함수인 경우 활성화 객체를 변수 객체로 사용한다. 활성화 객체는 항상 argumentsObj 객체로 시작한다. 이 객체는 전역 실행 컨텍스트의 변수 객체에는 존재하지 않는다. fnA 함수는 param1을 매개변수로 가지므로 fnAExecutionContextObj 객체의 argumentsObj 객체에 param1을 추가하고 활성화 객체의 프로퍼티로 param1을 만든다. 변수 b가 현재 함수의 활성화 객체에 존재하는 프로퍼티인지 확인하고 찾는다. 변수 b는 현재 함수에 존재하지 않으므로 활성화 객체의 프로퍼티로 b를 추가하고 undefined 값으로 초기화한다. 변수 a는 선언이 아니므로 다음 줄을 진행한다. JS 엔진은 fnB 함수 정의를 힙 메모리에 저장하고 이곳을 가리키는 포인터 값을 설정한다.실행 단계 - 함수 실행 컨텍스트생성 단계를 마치면 JS 엔진이 함수의 코드를 다시 한번 스캔하며 변수 객체를 변수의 값으로 업데이트하고 코드를 실행한다.실행 단계에서 함수 실행 컨텍스트 객체는 다음과 같다.fnAExecutionContextObj = { activationObj: { argumentsObj: { 0: param1, length: 1 }, pram1: 70, b: 2, fnB: Pointer to the function definition }, scopeChain: [fnA variable object, GEC variable object], this: window} 변수 b는 fnA 활성화 객체에 존재하므로 값을 2로 업데이트한다. JS 엔진은 변수 a가 fnA 함수 실행 컨텍스트에서 활성화 객체의 프로퍼티가 아님을 확인하고 스코프 체인을 통해 전역 실행 컨텍스트의 변수 객체에 접근한다. 전역 실행 컨텍스트의 변수 객체에 a라는 이름의 프로퍼티가 있는지 확인하고, 존재 한다면 a의 값을 1로 업데이트한다. 만약 존재하지 않는다면 JS 엔진은 전역 실행 컨텍스트의 변수 객체에 a라는 이름으로 프로퍼티를 만들고 초기화한다.이후 fnB 함수를 호출하면 위와 같은 단계를 거쳐 fnB 함수 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 추가한다.각주 Nicholas C. Zakas(2012), “JavaScript for Web Developers” ECMAScript® 2022 Language Specification, Execution Contexts javaTpoint, JavaScript Execution Context ui.dev, The Ultimate Guide to Hoisting, Scopes, and Closures in JavaScript" }, { "title": "JavaScript - 원시 값과 참조 값 &amp; 값 복사(Primitive and Reference Values &amp; Copying Values)", "url": "/posts/javascript-primitive-and-reference-values-and-copying-values/", "categories": "Programming, JavaScript", "tags": "javascript, primitive values, reference values, copying values, object cloning, shallow copy, deep copy, 자바스크립트, 원시 값, 참조 값, 값 복사, 객체 복제, 얕은 복사, 깊은 복사", "date": "2021-07-08 17:50:00 +0900", "snippet": "값 복사값에 의한 값 복사let num1 = 5;let num2 = num1;num1 = 10;console.log(num2); // 5num1에는 5가 저장되어 있다. num1을 num2에 대입하면 num1에 저장된 값 5를 새로 생성한 뒤에 값 복사가 이루어진다.num1과 num2는 각각 독립적인 존재이기 때문에 어느 한쪽에서 값이 바뀌어도 다른 쪽에는 영향이 없다.참조에 의한 값 복사참조 값 같은 경우 변수를 다른 변수에 복사할 때 원시 값과는 다른 방식으로 값 복사가 이루어진다.참조 값은 변수에 객체 자체가 저장되는 것이 아니라 객체에 대한 참조 값이 저장되기 때문에 다른 변수에 복사할 때도 객체 자체가 아닌 참조 값이 복사된다.let obj1 = new Object();let obj2 = obj1;obj1.name = &#39;Gunn&#39;;console.log(obj2.name); // &#39;Gunn&#39;obj1에 Object의 인스턴스를 할당하고 obj2에 obj1을 대입했다.obj1과 obj2는 같은 참조 값을 갖고 있으므로 obj1에 프로퍼티를 추가하면 obj2에서도 해당 프로퍼티에 접근할 수 있다.객체 복제얕은 복사객체를 복사할 때 참조 값을 복사하는 것이 아닌 값으로서 독립적인 객체를 만드는 방법은 다음과 같다.let person = { name: &#39;Gunn&#39;, age: 30};let clone = {};for(let key in person) { clone[key] = person[key];}console.log(person, clone, person === clone); // falseclone.name = &#39;Jun&#39;;console.log(person.name); // Gunnfor...in문으로 객체의 모든 프로퍼티를 순회하면 원시 타입의 값 복사가 가능하다.12번 줄에서 person과 clone를 출력해 두 객체의 프로퍼티가 같은 것을 확인했다.하지만 두 변수의 참조 값이 다르기 때문에 비교 연산에서 false가 된다.한편 객체의 프로퍼티는 또 다른 객체의 참조 값을 가질 수도 있다. 이런 경우 참조 값이 복사되기 때문에 완전히 복사가 되었다고 할 수 없다.이런 값 복사를 가리켜 얕은 복사(shallow copy)라고 한다.깊은 복사중첩 객체까지 완전히 복사하는 것을 가리켜 깊은 복사(deep copy)라고 한다.let student = { name: &#39;Gunn&#39;, age: 30, grades: { korean: 96, english: 70, math: 90 }};let clone = JSON.parse(JSON.stringify(student));console.log( student.grades, clone.grades, student.grades === clone.grades); // falseJSON.stringify 메서드는 값을 JSON 문자열로 변환해준다.JSON.parse 메서드는 JSON 문자열을 분석해서 값이나 객체로 생성해준다.중첩 객체를 포함한 전체를 원시 값인 문자열로 바꾼 뒤 객체를 생성하기 때문에 참조 값은 복사되지 않는다.하지만 JSON.stringify 메서드를 사용해 문자열로 변환하는 과정에서 undefined, function, symbol은 소실되거나 null로 변환되기 때문에 주의가 필요하다.- 재귀 함수를 사용한 깊은 복사재귀 함수를 직접 정의해서 사용하면 중첩 객체는 물론 모든 값을 복사할 수 있다.function cloneObj(obj) { let cloneObject = {}; for (let key in obj) { if (typeof obj[key] == &#39;object&#39; &amp;amp;&amp;amp; obj[key] != null) { cloneObject[key] = cloneObj(obj[key]); } else { cloneObject[key] = obj[key]; } } return cloneObject;}각주 Nicholas C. Zakas(2012), “JavaScript for Web Developers” JAVASCRIPT.INFO, 참조에 의한 객체 복사" }, { "title": "JavaScript - 원시 값과 참조 값 &amp; 동적 프로퍼티(Primitive and Reference Values &amp; Dynamic Properties)", "url": "/posts/javascript-primitive-and-reference-values-and-dynamic-properties/", "categories": "Programming, JavaScript", "tags": "javascript, primitive values, reference values, dynamic properties, primitive wrapper objects, 자바스크립트, 원시 값, 참조 값, 동적 프로퍼티, 원시 래퍼 객체", "date": "2021-07-07 05:00:00 +0900", "snippet": "원시 값과 참조 값자바스크립트의 변수에는 원시 값과 참조 값 두 가지 타입의 값을 저장할 수 있다. 원시 값 string, number, bigint, boolean, undefined, symbol, null 참조 값 object변수에 값이 할당되면 자바스크립트 엔진은 할당된 값이 원시 값인지 참조 값인지 판단하게 되는데 어떤 값이냐에 따라 값에 접근하는 방식이 다르다.원시 값은 변수에 실제 값으로 저장되기 때문에 값으로 접근하지만 참조 값은 객체 자체가 저장되는 것이 아니라 객체에 대한 참조 값이 저장되기 때문에 참조로 접근한다.즉, 참조 값을 저장하고 있는 변수는 메모리에 저장된 객체를 가리키는 포인터 역할을 하는 것이다.💡 원시 값은 변경할 수 없다?let str = &#39;Hello&#39;;str[0] = &#39;J&#39;;console.log(str[0], str); // &#39;H&#39; &#39;Hello&#39;str = &#39;Jello&#39;;console.log(str); // &#39;Jello&#39;모든 원시 값은 변경할 수 없다.변수에 새로운 문자열을 재할당해서 값을 변경하는 것만 가능하다.6번 줄에서 str 변수에 새로운 문자열 Jello가 할당되면 Hello는 소멸된다.동적 프로퍼티let person = new Object();person.name = &#39;Gunn&#39;;person.sayName = function () { console.log(`저의 이름은 ${this.name} 입니다.`);}console.log(person.name); // &#39;Gunn&#39;let name = &#39;Gunn&#39;;name.age = 30;console.log(name.age); // undefined객체를 생성해 person이란 변수에 저장하고 person 객체에 name 프로퍼티와 sayName 메서드를 추가했다.이처럼 참조 값에는 프로퍼티와 메서드를 추가하거나 삭제할 수 있다.반면에, 원시 값에는 프로퍼티나 메서드를 추가할 수 없다.프로퍼티를 추가하고 접근하려하면 non-strict mode에서는 13번 줄과 같이 undefined를 반환하고, strict mode에서는 에러가 발생한다.원시 래퍼 객체null과 undefined를 제외한 모든 원시 값은 객체처럼 메서드를 호출할 수 있는데, 원시 값을 래핑한 객체를 갖기 때문이다.12원시 래퍼 객체는 원시 값의 타입에 따라 관련 프로토타입을 상속한다.let str = &#39;Hello&#39;;console.log( str.toUpperCase() ); // &#39;HELLO&#39;문자열이 저장된 str 변수에 메서드를 호출했을 때 자바스크립트 내부적으로 다음과 같이 동작한다. 먼저 원시 값이 프로퍼티에 접근하는 순간 특별한 객체인 래퍼 객체가 생성된다. 이 래퍼 객체는 Number 객체의 프로토타입을 상속한다. toUpperCase 메서드가 실행되면 새로운 문자열을 반환하고 래퍼 객체는 소멸된다. 각주 Nicholas C. Zakas(2012), “JavaScript for Web Developers” 자바스크립트 창안자는 원시 값을 다룰 때 작업을 수월하게 수행하기 위한 방법으로 원시 래퍼 객체라는 개념을 도입했다. &amp;#8617; 원시 래퍼 객체는 원시 값의 타입에 따라 종류가 다르며, 상속하는 메서드도 다르다. &amp;#8617; " }, { "title": "Electron - 일렉트론 앱 만들기(Create an Electron App)", "url": "/posts/electron-create-an-electron-app/", "categories": "Framework, Electron", "tags": "electron, electron app, create an electron app, getting started with electron, 일렉트론, 일렉트론 앱, 일렉트론 앱 만들기, 일렉트론 시작하기", "date": "2021-07-02 03:25:00 +0900", "snippet": "일렉트론 시작하기초기 셋업일랙트론을 시작하기 위해서는 Node.js, npm, Electron, Chromium을 설치해야한다.Node.js와 npm 설치 후 터미널에 다음 명령을 실행해 관련 패키지를 설치한다.npm i -D electron@latest프로젝트 폴더를 만들고 터미널에 다음 명령을 실행해 관련 패키지를 설치한다.npm install --save-dev electronpackage.json 파일의 형식은 다음과 같아야 한다.{ &quot;name&quot;: &quot;my-electron-app&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Hello World!&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;author&quot;: &quot;my name&quot;, &quot;license&quot;: &quot;MIT&quot;} name : 애플리케이션 이름 version : 앱 버전 main : 애플리케이션의 entry point로 main.js로 설정해야한다. 개발 모드에서 앱을 열 수 있도록 scripts를 추가한다.&quot;scripts&quot;: { &quot;start&quot;: &quot;electron .&quot;}웹 페이지 생성하기앱에 로드될 콘텐츠를 만들기 위해 루트 폴더에 index.html을 생성한다.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP --&amp;gt; &amp;lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;&quot;&amp;gt; &amp;lt;meta http-equiv=&quot;X-Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;self&#39;&quot;&amp;gt; &amp;lt;title&amp;gt;Hello World!&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt; We are using Node.js &amp;lt;span id=&quot;node-version&quot;&amp;gt;&amp;lt;/span&amp;gt;, Chromium &amp;lt;span id=&quot;chrome-version&quot;&amp;gt;&amp;lt;/span&amp;gt;, and Electron &amp;lt;span id=&quot;electron-version&quot;&amp;gt;&amp;lt;/span&amp;gt;. &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;브라우저 윈도우에 웹 페이지 로드하기앱에 웹 페이지를 로드하기 위해 entry point로 설정했던 main.js를 생성하고 두 가지 모듈을 추가한다.- 앱의 이벤트 라이프사이클을 제어하는 app 모듈const { app, BrowserWindow } = require(&#39;electron&#39;)- 앱을 생성하고 관리하는 BrowserWindow 모듈function createWindow () { const win = new BrowserWindow({ width: 800, height: 600 }) win.loadFile(&#39;index.html&#39;)}createWindow 함수를 호출해 앱을 실행 👏Electron에서 브라우저 윈도우는 앱 모듈에 ready 이벤트가 전달된 후에 생성할 수 있다.app 모듈에 whenReady API를 사용해서 이벤트를 기다리고 then 메서드가 Promise를 리턴한 후 createWindow 함수를 호출하도록 한다.app.whenReady().then(() =&amp;gt; { createWindow()})터미널에 npm start 명령을 실행해 앱을 오픈한다.일렉트론 앱 실행 윈도우윈도우 라이프사이클 관리하기모든 윈도우가 닫히면 앱 종료하기(Windows &amp;amp; Linux)윈도우즈와 리눅스에서는 보통 모든 윈도우가 닫히면 앱이 종료된다.이를 구현하기 위해 app 모듈에 window-all-closed 이벤트가 전달되면 app.quit()를 호출해서 앱을 종료하도록 함수를 작성한다.하지만 맥OS의 경우 보통 열려 있는 윈도우가 없어도 앱이 계속 실행되며, 사용 가능한 윈도우가 없을 때 앱을 활성화하면 새 앱이 열린다.즉, 맥OS 환경에서는 사용자가 명시적으로 앱을 종료시키지 않는 이상 모든 윈도우가 닫혀도 앱이 계속 실행되도록 해야하기 때문에 프로세스의 플랫폼 값을 체크하는 조건문을 추가해야한다.app.on(&#39;window-all-closed&#39;, function () { if (process.platform !== &#39;darwin&#39;) app.quit()})열려있는 윈도우가 없으면 새 윈도우 열기(macOS)맥OS 환경에서 열려있는 윈도우가 없을 때 앱을 활성화하면 새 앱이 열리게 하는 방법은 다음과 같다.app 모듈에 activate 이벤트가 전달되면 열려있는 윈도우 개수를 체크해서 0개이면 createWindow 메서드를 호출해 새 앱을 열 수 있도록 한다.윈도우는 ready 이벤트가 발생하기 전에는 생성할 수 없으므로 앱이 초기화 된 후에 activate 이벤트를 받아야한다.whenReady 콜백 내에서 이벤트 리스너를 연결하면 된다.app.whenReady().then(() =&amp;gt; { createWindow() app.on(&#39;activate&#39;, function () { if (BrowserWindow.getAllWindows().length === 0) createWindow() })})Node.js API에 엑세스하기main 프로세스에서 Node의 전역 프로세스 객체를 통해 정보에 접근 하는 것은 가능하지만 renderer의 문서 컨텍스트에는 접근할 수 없기 때문에 DOM을 수정하는 것은 불가능하다.renderer에 preload 스크립트를 추가하면 문서 컨텍스트에 접근할 수 있다.preload 스크립트는 renderer 프로세스가 로드되기 전에 실행되며, renderer 전역과 Node.js 환경에 모두 접근할 수 있다.모든 Node.js API는 preload 프로세스에서 사용할 수 있다.preload.js 파일을 생성하고 다음 코드를 추가한다.window.addEventListener(&#39;DOMContentLoaded&#39;, () =&amp;gt; { const replaceText = (selector, text) =&amp;gt; { const element = document.getElementById(selector) if (element) element.innerText = text } for (const dependency of [&#39;chrome&#39;, &#39;node&#39;, &#39;electron&#39;]) { replaceText(`${dependency}-version`, process.versions[dependency]) }})위 코드는 Node.js의 process.versions 객체에 접근해 프로세스 버전을 HTML 요소에 삽입하는 함수를 실행한다.이 스크립트를 renderer 프로새스애 연결하기 위해 preload 스크립트 경로를 BrowserWindow 생성자의 webPreferences.preload 옵션에 추가해야한다.main.js 파일에 다음 코드를 추가한다.const { app, BrowserWindow } = require(&#39;electron&#39;)const path = require(&#39;path&#39;)function createWindow () { const win = new BrowserWindow({ width: 800, height: 600, webPreferences: { preload: path.join(__dirname, &#39;preload.js&#39;) } }) win.loadFile(&#39;index.html&#39;)}// ...2번 줄에 Node.js path 모듈을 추가하고 8번 줄에 preload.js를 연결하는 코드를 작성했다.각주 일렉트론 공식 문서" }, { "title": "JavaScript - 데이터 타입 &amp; 문자열 타입(Data Types &amp; The String Type)", "url": "/posts/javascript-data-types-and-the-string-type/", "categories": "Programming, JavaScript", "tags": "javascript, data types, the string type, 자바스크립트, 데이터 타입, 문자열 타입, 문자열 관련 메서드", "date": "2021-07-01 22:55:00 +0900", "snippet": "문자열 타입자바스크립트는 타 언어와 달리 글자 하나만 저장하는 데이터 타입이 없다.모든 글자는 문자열 형태로 저장되며, 인코딩 방식에 상관없이 UTF-16 형식을 따른다.1&#39;use strict&#39;let str = &#39;Hello&#39;;str[0] = &#39;J&#39;; // TypeError: Attempted to assign to readonly property.console.log(str[0]); // &#39;H&#39;자바스크립트의 문자열은 immutable이기 때문에 글자를 바꾸려고 하면 읽기 전용 속성에 할당을 시도했다며 TypeError가 발생한다.문자열을 바꾸려면 새로운 문자열을 생성한 후 변수에 할당하면 된다.문자열 관련 메서드특정 위치의 글자 찾기- charAt 문법 str.charAt(index)let str = &#39;Hello&#39;;str[0]; // &#39;H&#39;str.charAt(0); // &#39;H&#39;str[9]; // undefinedstr.charAt(9); // &#39;&#39;두 방법 모두 특정 위치의 글자에 접근할 수 있지만 접근하려는 위치에 글자가 없으면 str[]는 undefined를 반환하고, charAt은 빈 문자열을 반환한다.부분 문자열 찾기- indexOf 문법 str.indexOf(searchValue[, fromIndex])let str = &#39;Hello Human!&#39;;str.indexOf(&#39;H&#39;); // 0str.indexOf(&#39;H&#39;, 1); // 6str.indexOf(&#39;man&#39;); // 8첫 번째 인수로 문자열을 입력하면 문자열의 첫 글자가 어느 위치부터 시작하는지 알 수 있다.두 번째 인수로 정수값을 넘기면 문자열을 찾기 시작하는 위치를 지정할 수 있다.글자의 위치를 찾을 수 없으면 -1을 반환한다.- includes 문법 str.includes(searchString[, position])let str = &#39;Hello Human!&#39;;str.includes(&#39;Hello&#39;); // truestr.includes(&#39;girl&#39;); // falsestr.includes(&#39;l&#39;, 4); // false단순히 문자열의 포함 여부만 확인할 수 있다.두 번째 인수로 정수값을 넘기면 문자열을 찾기 시작하는 위치를 지정할 수 있다.- startsWith &amp;amp; endsWith 문법 str.startsWith(searchString[, position]) str.endsWith(searchString[, length])let str = &#39;Hello Human!&#39;;str.startsWith(&#39;Hello&#39;); // truestr.startsWith(&#39;Human&#39;); // falsestr.startsWith(&#39;Human&#39;, 6); // true첫 번째 인수로 넘긴 문자열로 시작하는지의 여부를 확인할 수 있다.두 번째 인수로 정수값을 넘기면 그 위치부터 확인한다.endsWith 메서드는 첫 번째 인수로 넘긴 문자열로 끝나는지의 여부를 확인할 수 있다.각주 Nicholas C. Zakas(2012), “JavaScript for Web Developers” 위키백과 : UTF-16 &amp;#8617; " }, { "title": "JavaScript - 데이터 타입 &amp; 숫자 타입(Data Types &amp; The Number Type)", "url": "/posts/javascript-data-types-and-the-number-type/", "categories": "Programming, JavaScript", "tags": "javascript, data types, the number type, infinity, nan, not a number, 자바스크립트, 데이터 타입, 숫자 타입, 무한대, 숫자가 아님", "date": "2021-06-30 17:20:00 +0900", "snippet": "숫자 타입15; // 1515.134; // 15.134010 // 80xA // 102 ** 9999 // Infinity(-2) ** 9999 // -Infinity15.00 // 151 * (10 ** 21) // 1e+211 / 10000000 // 1e-71 / &#39;문자&#39; // NaN4번 줄은 8진법으로 숫자 8을 표현했다. 8진수는 첫 번째 숫자가 0으로 시작해야 한다.5번 줄은 16진법으로 숫자 10을 표현했다. 16진수는 0x로 시작해야 한다.7번과 8번 줄은 ECMAScript로 나타낼 수 있는 숫자 범위를 벗어났기 때문에 양의 무한대 Infinity와 음의 무한대 -Infinity로 결과를 출력한다.연산 결과로 Infinity 값을 반환하면 더 이상 연산을 수행할 수 없다.10번 줄의 부동소수점 15.00과 같이 소수점 이하 숫자가 0이면 정수로 나타낸다.12번과 13번 줄은 숫자의 크기가 너무 크거나 작기 때문에 지수 표기법으로 나타낸다.부동소수점의 경우 소수점 이하 숫자의 개수가 7개 이상이면 지수 표기법으로 변환한다.자바스크립트의 숫자 타입은 다음과 같은 특징이 있다. ECMAScript는 IEEE 754의 64비트 배정밀도 형식을 통해 부동소수점을 나타낸다.1 숫자 리터럴은 기본적으로 10진법을 사용하며, 8진법과 16진법을 사용해 진수를 나타낼 수 있다. 나타낼 수 있는 숫자 범위를 벗어나면 Infinity 또는 -Infinity 값을 반환한다. 부동소수점 숫자를 메모리에 저장할 때는 정수 보다 큰 메모리 공간을 사용하기 때문에 소수점 이하 숫자가 0이면 정수로 표현한다. 나타낼 숫자가 너무 크거나 작으면 지수 표기법으로 나타낸다. 부정확한 연산은 NaN 값을 반환한다. Infinity, -Infinity, NaN의 자료형은 number이다.NaN숫자 타입 값 중에 NaN는 숫자를 반환할 것으로 의도한 실행이 실패했을 때 반환하는 값으로 Not a Number의 줄임말이다.NaN는 에러를 발생시키거나 코드 실행을 멈추지 않기 때문에 어느 단계에서 NaN 값이 반환됐는지 파악하기 어렵다.let value = 1 / &#39;string&#39;;if (value == NaN) { console.log(&#39;숫자가 아님.&#39;);}1번 줄은 숫자와 문자열의 나눗셈이기 때문에 변수 value에는 NaN의 값이 대입되었다.변수 value 값이 NaN이면 if문이 실행되기를 기대했지만 if문은 실행되지 않는다.NaN은 NaN을 포함하여 어떤 값과도 일치하지 않기 때문에 if문이 실행되지 않은 것이다.NaN 값 판별- Number.isNaNNumber.isNaN(NaN); // trueNumber.isNaN(&quot;NaN&quot;); // falseNumber.isNaN(10); // falseNumber.isNaN(&#39;10&#39;); // falseNumber.isNaN(&#39;string&#39;); // falseNumber.isNaN(true); // falseNumber.isNaN({}); // falseNumber.isNaN(undefined); // falseNumberl.isNaN 메서드는 인수 값의 데이터 타입이 number이고 값이 NaN이면 true, 아니면 false를 반환한다.Number.isNaN 메서드를 사용하면 정확하게 NaN 값만 판단할 수 있다.Object.is 메서드를 사용하면 보다 엄격하게 값을 판별할 수 있다.- Object.isObject.is(NaN, NaN); // trueObject.is(&#39;string&#39;, &#39;string&#39;); // trueObject.is(window, window); // trueObject.is(undefined, undefined); // trueObject.is(&#39;string&#39;, &#39;Str&#39;); // falseObject.is({}, {}); // falseObject.is([], []); // falsevar obj = { key: &#39;value&#39; };Object.is(test, test); // trueObject.is(null, null); // trueObject.is(0, -0); // falseObject.is(-0, -0); // trueObject.is(NaN, 0/0); // true== 연산은 형 변환 후 값을 비교하고, === 연산은 0과 -0을 같게 여기기 때문에 정확한 판별이 어려울 수 있지만 Object.is 메서드는 엄격한 규칙을 적용하기 때문에 정확한 판별이 가능하다.다음 조건 중 하나를 만족하면 ture를 반환한다. 두 값이 undefined 일 때 두 값이 null 일 때 두 값이 true 또는 false 일 때 두 값이 같은 문자에 같은 길이인 문자열 일 때 두 값이 같은 객체 일 때각주 Nicholas C. Zakas(2012), “JavaScript for Web Developers” IEEE 754는 IEEE에서 개발한 표준으로 컴퓨터에서 부동소수점을 표현하는 4가지 형식을 정의한다. &amp;#8617; " }, { "title": "JavaScript - 함수의 인수(Argument of a function)", "url": "/posts/javascript-argument-of-a-function/", "categories": "Programming, JavaScript", "tags": "javascript, functions, parameter, arguments, signature, function overloading, 자바스크립트, 함수, 매개변수, 인수, 시그니처, 함수 오버로딩", "date": "2021-06-27 14:10:00 +0900", "snippet": "함수의 인수function sum() { let total = 0; for(arg in arguments) { total += arguments[arg]; } console.log(total);}sum(10, 5); // 15sum(10, &#39; 더하기 &#39;, 5, &#39;는?&#39;); // 10 더하기 5는?sum함수의 매개변수를 선언하지 않았지만 sum함수를 호출할 때 여러 개의 인수를 매개변수로 넘겼다.하지만 인터프리터는 에러로 판단하지 않으며, 프로그램은 정상적으로 동작한다.이는 자바스크립트의 언어의 특징으로 함수 시그니처를 약타입으로 정의하기 때문에 함수에 선언된 매개변개수나 타입에 상관없이 인수로 값을 전달할 수 있다.자바스크립트의 매개변수는 다음과 같은 특징이 있다. 자바스크립트 함수의 매개변수는 내부적으로 배열로 표현되기 때문에 함수 시그니처를 만들고 매개변수의 개수나 타입을 체크하지 않는다.1 매개변수는 함수 내부에서 arguments라는 객체를 통해 매개변수의 값에 접근할 수 있다.arguments 객체function sum(num1, num2, num3) { if(arguments.length == 1) { console.log(arguments[0] + 10); } else if (arguments.length == 2) { console.log(arguments[0] + arguments[1]); } else if (arguments.length == 3) { console.log(arguments[0] + arguments[1] + num3); }}sum(10); // 20sum(10, 5); // 15sum(10, 5, 15); // 30인수가 1개이면 if문이 실행되고, 2개 또는 3개이면 else if문이 실행된다.arguments 객체를 사용해 num1, num2, num3 변수의 값에 접근했다.이런 자바스크립트 언어의 특징을 이용하면 내부적으로 매개변수의 개수나 타입을 체크하지 않더라도 오버로딩과 비슷하게 동작하는 함수를 만들 수 있다.arguments 객체는 다음과 같은 특징이 있다. arguments는 [] 표기법으로 매개변수 값에 접근할 수 있다. 매개변수명 대신에 arguments를 사용할 수 있고, 혼용해서 사용할 수도 있다. arguments.length로 매개변수의 개수를 알 수 있어 배열처럼 동작하지만 Array의 인스턴스는 아니다. n 번째 매개변수의 값과 n 번째 argument[n] 값은 서로 대응 관계이기 때문에 어느 한쪽에 값이 바뀌면 다른 한쪽에서도 값이 바뀐다. 하지만 같은 메모리 공간을 사용하는 것은 아니다. strict mode에서 n번째 매개변수의 값과 argument[n] 값은 서로 대응하지 않는다.- 4번 특징 예시function sum(num1, num2) { arguments[0] = 20; console.log(num1, num2); console.log(arguments[0], num2); num1 = 10; console.log(arguments[0], num2);}sum(10, 20);// 20 20// 20 20// 10 20non-strict mode에서 arguments[0]값과 num1값은 서로 대응하기 때문에 어느 쪽에서 값이 바뀌면 다른 한쪽에도 바뀐 값이 반영된다.하지만 strict mode에서는 두 값이 서로 대응하지 않는다.- 5번 특징 예시&quot;use strict&quot; // Using strict modefunction sum(num1, num2) { arguments[0] = 20; console.log(num1, num2); console.log(arguments[0], num2); num1 = 10; console.log(arguments[0], num2);}sum(10, 20);// 10 20// 20 20// 20 20arguments 객체에는 값을 재할당하는 것이 가능하다.단, strict mode에서는 에러를 발생시킨다.function sum(num1, num2) { arguments = [20, 30]; console.log(arguments[0], arguments[1]);}sum(10, 20);// 20 30각주 Nicholas C. Zakas(2012), “JavaScript for Web Developers” 자바스크립트의 함수 시그니처(signature)는 약타입(loosely typed)으로 정의한다. &amp;#8617; " } ]
